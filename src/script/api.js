import SHA1 from 'crypto-js/sha1.js';
import * as AutoGeneratedClient from '../gen/index.js'

let _key = '';
let _secret = '';
let _timeout = 30;
let _accessToken = undefined;

function getApiClient(timeout) {
    let timeOutMill = (timeout || _timeout) * 1000;
    let apiClient = new AutoGeneratedClient.ApiClient();
    apiClient.timeout = timeOutMill;
    if (_accessToken) {
        apiClient.defaultHeaders['Authorization'] = _accessToken;
    }
    return apiClient;
}

/**
 * 
 * @param {string} app_key 
 * @param {string} app_secret 
 */
function config(app_key, app_secret, timeout=30) {
    _key = app_key;
    _secret = app_secret;
    _timeout = timeout;
}

/**
 * refresh Authorization by app_key and app_secret, 
 * so this method must called after config(app_key, app_secret)
 * @returns 
 */
async function getAccessToken() {
    if (!_key || !_secret) {
        throw Error('app_key or app_secret not set');
    }
    let time = (Date.now() / 1000).toFixed(0);
    let str = _key + time + _secret;
    let sign = SHA1(str).toString();

    let api = new AutoGeneratedClient.TokenControllerApi(getApiClient());
    let ret = await new Promise((resolve, reject) => {
        api.getAccessTokenUsingPOST({
                body: {
                    app_key: _key,
                    sign: sign,
                    time: time
                }
            }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    if(ret && ret.result){
        _accessToken = ret.result.access_token;
    }
    return ret;
}

/**
 * 
 * @param {string} name  one of the API_NAMES
 * @param {int} timeout Not required, default is 30 or setup by config function
 * @returns 
 */
async function supportedChains(name, timeout) {
    if(name && !API_NAMES[name]){
        throw Error('Api name not supported');
    }
    let api = new AutoGeneratedClient.TokenControllerV1Api(getApiClient(timeout));
    let ret = await new Promise((resolve, reject) => {
        api.getChainsListUsingGET({}, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}

const API_NAMES = {
    token_security: 'token_security',
    address_security: 'address_security',
    approval_security: 'approval_security',
    token_approval_security: 'token_approval_security',
    nft721_approval_security: 'nft721_approval_security',
    nft1155_approval_security: 'nft1155_approval_security',
    input_decode: 'input_decode',
    nft_security: 'nft_security'
}

/**
 * Only return result for the first token when the Authorization not set
 * @param {string} chainId 
 * @param {string[]} tokens 
 * @param {int} timeout Not required, default is 30 or setup by config function
 */
async function tokenSecurity(chainId, tokens, timeout) {
    let api = new AutoGeneratedClient.TokenControllerV1Api(getApiClient(timeout));
    let ret = await new Promise((resolve, reject) => {
        api.tokenSecurityUsingGET1(chainId, tokens, {
            Authorization: _accessToken
        }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}

/**
 * 
 * @param {string} chainId 
 * @param {string} address 
 * @param {int} timeout Not required, default is 30 or setup by config function
 * @returns 
 */
async function addressSecurity(chainId, address, timeout) {
    let api = new AutoGeneratedClient.ApproveControllerV1Api(getApiClient(timeout));
    let ret = await new Promise((resolve, reject) => {
        api.addressContractUsingGET1(address, {
            chain_id: chainId,
            Authorization: _accessToken
        }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}

/**
 * 
 * @param {string} chainId 
 * @param {string} address 
 * @param {int} timeout Not required, default is 30 or setup by config function
 * @returns 
 */
async function approvalSecurity(chainId, address, timeout) {
    let api = new AutoGeneratedClient.ApproveControllerV1Api(getApiClient(timeout));
    let ret = await new Promise((resolve, reject) => {
        api.approvalContractUsingGET(chainId, address, {
            Authorization: _accessToken
        }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}

/**
 * 
 * @param {string} chainId 
 * @param {string} address 
 * @param {int} timeout Not required, default is 30 or setup by config function
 * @returns 
 */
async function erc20ApprovalSecurity(chainId, address, timeout) {
    let api = new AutoGeneratedClient.ApproveControllerV2Api(getApiClient(timeout));
    let ret = await new Promise((resolve, reject) => {
        api.addressTokenApproveListUsingGET1(address, chainId, {
            Authorization: _accessToken
        }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}

/**
 * 
 * @param {string} chainId 
 * @param {string} address 
 * @param {int} timeout Not required, default is 30 or setup by config function
 * @returns 
 */
async function erc721ApprovalSecurity(chainId, address, timeout) {
    let api = new AutoGeneratedClient.ApproveControllerV2Api(getApiClient(timeout));
    let ret = await new Promise((resolve, reject) => {
        api.addressNFT721ApproveListUsingGET1(address, chainId, {
            Authorization: _accessToken
        }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}

/**
 * 
 * @param {string} chainId 
 * @param {string} address 
 * @param {int} timeout Not required, default is 30 or setup by config function
 * @returns 
 */
async function erc1155ApprovalSecurity(chainId, address, timeout) {
    let api = new AutoGeneratedClient.ApproveControllerV2Api(getApiClient(timeout));
    let ret = await new Promise((resolve, reject) => {
        api.addressNFT1155ApproveListUsingGET1(address, chainId, {
            Authorization: _accessToken
        }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}

/**
 * 
 * @param {string} chainId 
 * @param {string} contractAddress 
 * @param {string} data 
 * @param {int} timeout Not required, default is 30 or setup by config function
 * @returns 
 */
async function inputDecode(chainId, contractAddress, data, timeout) {
    return inputDecodeWithOpts(chainId, contractAddress, data, {timeout});
}

/**
 * 
 * @param {string} chainId 
 * @param {string} contractAddress 
 * @param {string} data 
 * @param {Object} opts Optional parameters
 * @param {int} opts.timeout Not required, default is 30 or setup by config function.
 * @param {string} opts.signer Not required, the signer of this transaction.
 * @returns 
 */
async function inputDecodeWithOpts(chainId, contractAddress, data, opts) {
    opts = opts || {};
    let api = new AutoGeneratedClient.ContractAbiControllerApi(getApiClient(opts.timeout));
    let ret = await new Promise((resolve, reject) => {
        api.getAbiDataInfoUsingPOST({
            chain_id: chainId,
            signer: opts.signer,
            contract_address: contractAddress,
            data
        }, {
            Authorization: _accessToken
        }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}

/**
 * 
 * @param {string} chain_id 
 * @param {string} contract_address 
 * @param {int} timeout Not required, default is 30 or setup by config function
 * @returns 
 */
async function nftSecurity(chain_id, contract_address, token_id, timeout) {
    let api = new AutoGeneratedClient.NftControllerApi(getApiClient(timeout));
    let ret = await new Promise((resolve, reject) => {
        api.getNftInfoUsingGET1(chain_id, contract_address, { 
            token_id,
            Authorization: _accessToken
        }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}

/**
 * 
 * @param {string} dapp_url 
 * @param {int} timeout Not required, default is 30 or setup by config function
 * @returns 
 */
async function dappSecurity(dapp_url, timeout) {
    let api = new AutoGeneratedClient.DappControllerApi(getApiClient(timeout));
    let ret = await new Promise((resolve, reject) => {
        api.getDappInfoUsingGET({
            url: dapp_url,
            Authorization: _accessToken
        }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}


/**
 * 
 * @param {string} site_url 
 * @param {int} timeout Not required, default is 30 or setup by config function
 * @returns 
 */
async function phishingSite(site_url, timeout) {
    let api = new AutoGeneratedClient.WebsiteControllerApi(getApiClient(timeout));
    let ret = await new Promise((resolve, reject) => {
        api.phishingSiteUsingGET(site_url, {
            Authorization: _accessToken
        }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}

/**
 * 
 * @param {string} site_url 
 * @param {int} timeout Not required, default is 30 or setup by config function
 * @returns 
 */
async function rugpullDetection(chain_id, contract_addresses, timeout) {
    let api = new AutoGeneratedClient.DefiControllerApi(getApiClient(timeout));
    let ret = await new Promise((resolve, reject) => {
        api.getDefiInfoUsingGET(contract_addresses, chain_id, {
            Authorization: _accessToken
        }, (error, data, response) => {
            if (error) {
                if (error.errno === 'ETIME') {
                    resolve({ code: -1, message: "Request Timeout!" });
                } else {
                    reject(error);
                }
            } else {
                resolve(data);
            }
        })
    })
    return ret;
}

const GoPlus = {
    API_NAMES,
    config,
    getAccessToken,
    supportedChains,
    tokenSecurity,
    addressSecurity,
    approvalSecurity,
    erc20ApprovalSecurity,
    erc721ApprovalSecurity,
    erc1155ApprovalSecurity,
    inputDecode,
    inputDecodeWithOpts,
    nftSecurity,
    dappSecurity,
    phishingSite,
    rugpullDetection
}

export default GoPlus;